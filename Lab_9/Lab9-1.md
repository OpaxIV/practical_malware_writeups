# Lab 9.1

## Troubleshooting
Before you begin: When looking for strings, I recommend using a tool like **PEStudio**, since IDA did not find all strings in the binary. This can be frustrating, since the important "-in" argument (see Question 1) is nowhere to be found in the listing of IDA64.

Also important: looking at IDA and OllyDbg at the same time might lead to inconsistencies, since IDA does not know anything about rebasing. To fix this, use the "Manual Load" option in IDA and specify the virtual base address manually.
Steps to take:
- Check the debugger for the correct base and start address:
    <br>
    <img src="image-13.png" width="900">
    <br>
- In IDA, check the `start` function. The address should match up with the current address at which the program starts (in this case 0x403896).
- If these addresses do not match up, go under *Edit --> Segments -->  Rebase program* and set the base address as seen in the memory map of the debugger.
    <br>
    <img src="image-14.png" width="200">
    <br>
- In this case, the addresses match up, so there is no action needed from our part.

## Intial Analysis
Analyze the malware found in the file Lab09-01.exe using OllyDbg and IDA Pro to answer the following questions. This malware was initially analyzed in the Chapter 3 labs using basic static and dynamic analysis techniques.

- **PEStudio:**
    - Interesting Strings
        - "-in"
        - "-cc"
        - "command.com"
        - "COMSPEC" - Windows environment variable containing the directory path to the command shell
        - "GetActiveWindow" - 
        - "GetLastActivePopup" - 
        - "MessageBoxA" - Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error information.
        - "CreateFileA" - creates or opens a file
        - "GetSystemDirectoryA" - Retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers.
        - Manipulation of Environmental Variables
            - "ExpandEnvironmentStringsA" - Expands environment-variable strings and replaces them with the values defined for the current user
            - "SetEnvironmentVarialbeA" - sets the contents of the specified environment variable for the current process.
        - Registry Manipulations e.g. "RegCreateKeyExA" ...
        - "CreateServiceA" - 
        - "shell32.dll"
            - providing functions of the Windows Shell
            - includes desktop, Start Menu, Autoplay, Taskbar
            - needed to open web pages and files
            - residing in "C:\Windows\System32".
        - Process Management e.g. "GetCurrent Process" ...
        - "http://www.practicalmalwareanalysis.com"
        - "%SYSTEMROOT%\\system32\\"
    - Raw vs. Vitual Data Size
        - Note that deviations in the .data sections sizes are usual in Windows programs. 
        <table>
        <thead>
            <tr>
                <th>Section</th>
                <th>.text</th>
                <th>.rdata</th>
                <th>.data</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Raw</td>
                <td>0x0000A000 (40960 bytes)</td>
                <td>0x00001000 (4096 bytes)</td>
                <td>0x00003000 (12288 bytes)</td>
            </tr>
            <tr>
                <td>Virtual</td>
                <td>0x00009348 (37704 bytes)</td>
                <td>0x00000D70 (3440 bytes)</td>
                <td>0x000041BC (16828 bytes)</td>
            </tr>
        </tbody>
        </table>    
    
    - Imports
        - advapi32.dll (advanced core functionalities, Registry & Service Manager)
            - `RegCreateKeyExA` - 
            - `RegSetValueExA` - 
            - ...
        - kernel32.dll (common .dll, core functionalities)
            - ...
        - ws2_32.dll (used for networking functionalities)
            - ...
        - shell32.dll
            - `ShellExecuteA` - Performs an operation on a specified file.

- **IDA64:**
    -  Graph View
        - `main`
            <br>
            <img src="image.png" width="300">
            <br>
    - Program Flow
        - `main` at 0x402AF0
        - Compares `argc` with 1, if the result is not zero, a jump occurs to 0x402B1D, else to 0x402B03, where a sub-routine `sub_401000` is called. We can deduce from this finding, that the program only executes "the intended way" if an argument is passed prior to execution.
        - Looking into the FALSE Branch (`argc` == 1) we reach the first call to the function `sub_401000`. We see a call to the WinAPI function `RegOpenKeyExA`, which is used to open a registry key. The most interesting parameter being pushed onto the stack for this function is `SubKey`, which contains "SOFTWARE\\Microsoft \\XPS". According to the documentation of Microsoft, this path specified the sub key to be opened. The Microsoft XPS Document Writer (MXDW) is a print-to-file driver that enables a Windows application to create XML Paper Specification (XPS) document files.
        - The sub-function continues, if `RegOpenKeyExA` returns 0 (= `ERROR_SUCCESS`). Continuing at 0x401029 the sub-routine calls `RegQueryValueExA`, which retrieves the type and data for the specified value name associated with an open registry key. In our case `ValueName` "Configuration". Afterwards the sub-routine does some clean up and returns to the `main` function.
        - If sub_401000 returns 0, the program continues to 0x402B13 and calls another sub-routine `sub_402410`.


Note: The focus of this exercise lies more on the usage of ollydbg. Hence the dynamic analysis is more emphasized in this guide.


## Advanced Analysis
- **OllyDbg (1st attempt)**
    - entry point of the malware at 0x403896
    - stepping over (f8 or <img src="image-1.png" width="15"> in the toolbar) until we reach the address 0x403945, which is the call of the `main` function.
        <br>
        <img src="image-2.png"  width="400">
        <br>
    This call can most easly be found via IDA64. At the `main` function hit *CTRL+X*.
        <br>
        <img src="image-3.png" width="400">
        <br>
        <img src="image-4.png" width="300">
        <br>
    - Next step into the call (f7 or <img src="image-5.png" width="15"> in the toolbar). We can spot a comparision of `argc`, the argument count that was passed to `main`. Since we did not specify any argument, the count should be 1 (the name of the program counts the first argument residing at `argv[0]`). So the following check succeeds.
        <br>
        <img src="image-6.png" width="400">
        <br>
    - We reach the first call of a sub-routine at 0x402B03. Stepping into the call will lead us to the address 0x401000. In here we can see a call to the `RegOpenKeyExA` function. The function attempts to open the registry key *"SOFTWARE\\Microsoft \\XPS"*. Since this key does not exist, `RegOpenKeyExA` returns 0 (according to the book and also viewable in the debugger window). In my research and looking at the Windows API Reference (see below) the function returns 0 (= ERROR_SUCCESS) if the registry key has been opened successfully. I am unsure if this has been changed since Windows XP, but it is true, that the malware program terminates (in my WinXP VM) if the return value is 0 (hence an error occured).
        <br>
        <img src="image-7.png" width="500">
        <br>
    - The program continues at 0x402B13, in which another function `sub_402410` is called. In here functions like `GetModuleFileNameA` (used for retrieving the path of the current executable) and `GetShortPathNameA` (retrieves the short path form of the specified path) are called. When looking at it in OllyDbg we can see the values contained by the registers. As such we see the start of  a computation of a string, which contains two commands and the path to the executable: *"/c path-to-executable >> NUL"*.
        <br>
        <img src="image-8.png" width="700">
        <img src="image-9.png" width="700">
        <br>
    `ShellExecuteA` is then called, which execute the command. We reached the point at which the malware would delete itself and finish execution, but since the program is open in OllyDbg, Windows won't permit this operation. This is the end point of the first dynamic analysis of the malware sample.

- **OllyDbg (2nd attempt)**
    -  As we have seen before, there is a check at 0x402AFD, which must be satisfied to proceed with the normal execution of the program.
        <br>
        <img src="image-10.png" width="300">
        <br>
    - As explained in the book, we have two options: we could either patch the program to always resume execution or input different command line arguments (prefereable some of the strings we found) and as such try to reach the end of the program. Patching the program might have unintended effects, since later functions may depend on this part of the code.
    - Passing `-in` as an argument will lead us to 0x402B1D. The following instructions contain `argc` and `argv` of the `main` function. `argc` gets pushed first onto the stack at the offset [EBP+8], `argv` is then being pushed and in the end an arithmetic operation is being computed to retrieve the last element of the `argv` array. 
        <br>
        <img src="image-11.png" width="500">
        <br>
    - %edx now contains the pointer to the last argument since:
        ```
        [ECX + EAX * 4 - 4] = [argv + argc * 4 - 4]
        ```
        A visual example can be seen here (referenced below):
        <br>
        <img src="image-12.png" width="200">
        <br>
        The -4 in the end is due to the null-terminating character (see picture).
    - Proceeding with the program, we step into the call and reach 0x402510. // not yet finished commenting
        ```asm
                ; function call at 0x402510
        00402510  /$ 55             PUSH EBP
        00402511  |. 8BEC           MOV EBP,ESP
        00402513  |. 51             PUSH ECX
        00402514  |. 57             PUSH EDI

        00402515  |. 8B7D 08        MOV EDI,DWORD PTR SS:[EBP+8] ;
        00402518  |. 83C9 FF        OR ECX,FFFFFFFF
        0040251B  |. 33C0           XOR EAX,EAX
        0040251D  |. F2:AE          REPNE SCAS BYTE PTR ES:[EDI] ; used for strlen
        0040251F  |. F7D1           NOT ECX
        00402521  |. 83C1 FF        ADD ECX,-1
        00402524  |. 83F9 04        CMP ECX,4                   ; checks size of passed argument (4 bytes) --> ['-' 'i' 'n' '\0']
        00402527  |. 74 04          JE SHORT Lab09-01.0040252D  ; jmp to 0x40252D if arguments size == 4 bytes
        00402529  |. 33C0           XOR EAX,EAX
        0040252B  |. EB 73          JMP SHORT Lab09-01.004025A0 ; else jump to 0x4025A0 if arguments size != 4 bytes (end of function)

        0040252D  |> 8B45 08        MOV EAX,DWORD PTR SS:[EBP+8]    ; %eax = var_4
        00402530  |. 8A08           MOV CL,BYTE PTR DS:[EAX]        ; %cl = %eax = var_4
        00402532  |. 884D FC        MOV BYTE PTR SS:[EBP-4],CL      ; [EBP-4] = %cl
        00402535  |. 0FBE55 FC      MOVSX EDX,BYTE PTR SS:[EBP-4]   ; EDX = [EBP-4] = ... = var_4
        00402539  |. 83FA 61        CMP EDX,61                      ; %edx ? 0x61 (='a')
        0040253C  |. 74 04          JE SHORT Lab09-01.00402542      ; jmp to 0x402542 if var_4[0] == a
        0040253E  |. 33C0           XOR EAX,EAX
        00402540  |. EB 5E          JMP SHORT Lab09-01.004025A0     ; else jmp to end

        00402542  |> 8B45 08        MOV EAX,DWORD PTR SS:[EBP+8]    ; 
        00402545  |. 8A48 01        MOV CL,BYTE PTR DS:[EAX+1]
        00402548  |. 884D FC        MOV BYTE PTR SS:[EBP-4],CL
        0040254B  |. 8B55 08        MOV EDX,DWORD PTR SS:[EBP+8]
        0040254E  |. 8A45 FC        MOV AL,BYTE PTR SS:[EBP-4]
        00402551  |. 2A02           SUB AL,BYTE PTR DS:[EDX]
        00402553  |. 8845 FC        MOV BYTE PTR SS:[EBP-4],AL
        00402556  |. 0FBE4D FC      MOVSX ECX,BYTE PTR SS:[EBP-4]
        0040255A  |. 83F9 01        CMP ECX,1                       ; var_4[1] ? 0x01 (='')
        0040255D  |. 74 04          JE SHORT Lab09-01.00402563
        0040255F  |. 33C0           XOR EAX,EAX
        00402561  |. EB 3D          JMP SHORT Lab09-01.004025A0
        00402563  |> 8A45 FC        MOV AL,BYTE PTR SS:[EBP-4]
        00402566  |. B2 63          MOV DL,63                       ; var_4[2] ? 0x63 (='c')
        00402568  |. F6EA           IMUL DL
        0040256A  |. 8845 FC        MOV BYTE PTR SS:[EBP-4],AL
        0040256D  |. 0FBE45 FC      MOVSX EAX,BYTE PTR SS:[EBP-4]
        00402571  |. 8B4D 08        MOV ECX,DWORD PTR SS:[EBP+8]
        00402574  |. 0FBE51 02      MOVSX EDX,BYTE PTR DS:[ECX+2]
        00402578  |. 3BC2           CMP EAX,EDX
        0040257A  |. 74 04          JE SHORT Lab09-01.00402580
        0040257C  |. 33C0           XOR EAX,EAX
        0040257E  |. EB 20          JMP SHORT Lab09-01.004025A0
        00402580  |> 8A45 FC        MOV AL,BYTE PTR SS:[EBP-4]
        00402583  |. 04 01          ADD AL,1
        00402585  |. 8845 FC        MOV BYTE PTR SS:[EBP-4],AL
        00402588  |. 0FBE4D FC      MOVSX ECX,BYTE PTR SS:[EBP-4]
        0040258C  |. 8B55 08        MOV EDX,DWORD PTR SS:[EBP+8]
        0040258F  |. 0FBE42 03      MOVSX EAX,BYTE PTR DS:[EDX+3]
        00402593  |. 3BC8           CMP ECX,EAX
        00402595  |. 74 04          JE SHORT Lab09-01.0040259B
        00402597  |. 33C0           XOR EAX,EAX
        00402599  |. EB 05          JMP SHORT Lab09-01.004025A0
        0040259B  |> B8 01000000    MOV EAX,1

        004025A0  |> 5F             POP EDI
        004025A1  |. 8BE5           MOV ESP,EBP
        004025A3  |. 5D             POP EBP
        004025A4  \. C3             RETN
        ```
    - Analyzing this function will lead us to the conclusion, that some sort of a "password check" is implemented. If we look at the code section from 0x40251B to 0x402521 right at the beginning of the function, we will notice an implementation of the `strlen` function.
        ```asm
        .text:0040251B xor     eax, eax
        .text:0040251D repne scasb
        .text:0040251F not     ecx
        .text:00402521 add     ecx, 0FFFFFFFFh
        ```
    - To bipass this password check we can patch this function, such that it always returns 1. This will lead to the continuation of the programs execution. Looking at the function at 0x402510 via IDA, we see that 1 gets copied into %eax only when the check was true.
        <br>
        <img src="image-15.png" width="700">
        <br>
    - Using gdb (or any other tool that can transform byte code into assembly code) we get the following byte code for our wished instructions.
        ```asm
        0:  b8 01 00 00 00          mov    eax,0x1
        5:  c3                      ret
        ```
    - Go to the beginning of the function and click on the address 0x402510. Right click and choose *Binary -> Edit*. Make sure to uncheck the "Keep size" tick box, since we are overwriting an instruction of the size of 1 byte with 6 bytes.
        <br>
        <img src="image-17.png" width="250">
        <br>
    Which should then look like this.
        <br>
        <img src="image-18.png" width="250">
        <br>
        <br>
        <img src="image-19.png" width="300">
        <br>
    Next right click into the disassembly window and choose *Copy to executable -> All modifications*. Accept all and save the executable to disk (e.g. Lab09-01_patched.exe).
    - To check if the patching worked, rerun the program again with the argument `-in`. The program calls the "password check" function 0x402B2E, ends up at 0x402510 and returns. A check occurs which we successfully pass and arrive at 0x402B3F. We can now proceed with the execution of the program without worrying about the password to input.
        <br>
        <img src="image-20.png" width="300">
        <br>
    - If we look again at the program via IDA64, we see multiple occurences of the function `mbscmp`. This function compares strings, just like the other C implementation `strcmp`. `mbscmp` even contains `strcmp` at some point in the code.
    It is now crucial to understand what argument is being checked first, to proceed in the program. The argument should be contained in %eax before the call to `mbscmp`. IDA labels it as `Str1`, which is `-in`. This can be found out by backtracking through program or looking at the stack via debugger.
        <br>
        <img src="image-22.png" width="400">
        <br>
        <br>
        <img src="image-23.png" width="600">
        <br>
    - It is important to note, that the check still won't work, since two arguments need to be passed onto the stack ( the argument `Str1` and the password `Str2`). Even though the binary has been patched, the `mbscmp` still awaits two arguments instead of only one.
        <br>
        <img src="image-24.png" width="400">
        <br>
    - Set a breakpoint at 0x402B63 so quickly return to the current location and rerun the malware while passing the argument `-in` and a string (doesn't matter what, since the password check is patched).
    -  The malware checks if 3 or 4 arguments have been passed.
        <br>
        <img src="image-25.png" width="300">
        <br>
    - In our case the malware will jump to 0x402B69, since we only provided two parameters, and call the function `sub_4025B0` at 0x402B75. This named sub-routine contains the WinAPI function `GetModuleFileNameA` (retrieves fully qualified path for file that contains the specified module) and `_splitpath` (breaks a path into components).
        <br>
        <img src="image-26.png" width="300">
        <br>
    According to the Microsoft Wiki, if `hModule` is passed as a NULL value, the function will retrieve the path of the executable file of the current process, hence our malware. We can as such safely say, that this function  returns the path to the malware executable (or the name respectively). Furthermore for simplicity, I changed the name of this function to `get_filename`.
    - If the `get_filename` function returns normally, hence returns the name of the file, the malware proceeds to 0x402B89. At this point `sub_402600` gets called (0x402B90). This next function takes the name of the executable as a parameter (renamed to `create_service`).
        <br>
        <img src="image-27.png" width="700">
        <br>
    Again it calls `get_filename` to retrieve the name of the executable and copies the program to the path *"%SYSTEMROOT%\system32\"* in a later point of the function. A typical value for %SYSTEMROOT% is *"C:\Windows"*. Hence the full path would be *"C:\Windows\system32\"*, which is also the `BinaryPathname` of the then newly created service.
    - The function either creates a new service with the malware or tries to open the existing one. `OpenServiceA` returns the handle to the existing service if successful and returns NULL on the contrary. If the return value is NULL, the malware proceeds with the creation of a new service with the same name, which is made up by {"Name of the exe" - ".exe" +    "Manager Service"}. In my case it will be *"Lab09-01_patched Manager Service"*. 
    - Another interesting functionality of this function is the usage of `CopyPathA`, which as the name already says, is used to copy files from one point to another. Using dynamic analysis, we can find out the source and destintation path. Running the program until 0x4028A1 will present us the values via register view in OllyDbg.
        <br>
        <img src="image-28.png" width="1200">
        <br>
    If the `CopyFileA` function was successful, the program proceeds to 0x4028B2, in which the path of the destination file is passed to the function `sub_4015B0` (=`meta_changer` in my case).
    - Following the call we get to 0x4015B0.
        <br>
        <img src="image-29.png" width="350">
        <br>
    The function calls the WinAPI function `GetSystemDirectoryA`, which retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers. In IDA we can spot the string `kernel32.dll`. Furthermore glancing over the function at 0x401618, we see calls to `CreateFileA`, `GetFileTime` and `SetFileTime`. In conclusion we can safely assume, that this function modifies some meta data (time) of the newly copied file at *"C:\WINDOWS\system32\Lab09-01_patched.exe"*.
    - If the function is successfully executed, we proceed to 0x4028CC, where we see the following parameters being pushed onto the stack.
        ```asm
        .text:004028CC
        .text:004028CC loc_4028CC:
        .text:004028CC push    offset a60      ; "60"
        .text:004028D1 push    offset a80      ; "80"
        .text:004028D6 push    offset aHttpWwwPractic ; "http://www.practicalmalwareanalysis.com"
        .text:004028DB push    offset aUps     ; "ups"
        .text:004028E0 call    sub_401070
        .text:004028E5 add     esp, 10h
        .text:004028E8 test    eax, eax
        .text:004028EA jz      short loc_4028F3
        ```
    The sub-routine `sub_401070` (=`create_regXPS` in my case) is then called, which most notably contains `RegCreateKeyExA` with the parameter "SOFTWARE\\Microsoft \\XPS". The created key then resides at the path "HKLM\SOFTWARE\Microsoft \XPS" (space is intended). It then calls in a further step `RegSetValueExA`, which sets the contents of the newly created registry value according to its given parameters. In this case a buffer is being passed at 0x4011BE `.text:004011BE lea     edx, [ebp+Data]`. To find out what it holds, it is recommended to look at it via debugger. Set an initial breakpoint at 0x4028E0, which is at the call of `create_regXPS`.
        <br>
        <img src="image-30.png" width="400">
        <br>
    Step into the call and set a breakpoint at 0x4011BE. Execute until the breakpoint and *Right Click -> Follow in Dump -> Memory Address*. You will now see the memory dump of this location.
        <br>
            <img src="image-31.png" width="250">
        <br>
    We can now see the contents of the buffer, which are the URL *"http://www.practicalmalwareanalysis.com"* and the ports *80* and *60*.

- **Command Line Arguments**
    The above example has been run with the command line arguments `-in` and `"abcd"` (string value irrelevant due to the patch). As seen in the strings of the malware, there are many more parameters, that can be passed to the malware. To find these arguments in the code, we can look at the `main` function and search for calls to `__mbscmp`, which is responsible for comparing strings.
        <br>
        <img src="image-32.png" width="600">
        <br>
    IDA already recognizes the argument `-cc`, hence we can say that the specific code for this argument starts at 0x402CFD (after the comparision). If the `-in` parameter is passed, then (as we have already seen above) we land at the address 0x402B69 and call the function `create_service` at 0x402B90 (-> 0x402600). The other two options can be checked via debugger (depending on where we land in the code).

    `-in` --> `__mbscmp` at 0x402B57 -> code proceeds at 0x402B63<br>
    `-re` --> `__mbscmp` at 0x402BDF -> code proceeds at 0x402BEB<br>
    `-c`  --> `__mbscmp` at 0x402C67 -> code proceeds at 0x402C73<br>
    `-cc` --> `__mbscmp` at 0x402CF1 -> code proceeds at 0x402CFD<br>

    Looking at the code in depth we can conclude the following:
    - The option `-in` installs a service
        - for more detailed informations, see above
    - The option `-re` uninstalls a service
        - call to `get_filename`
        - call to `sub_402900` (=`delete_malware` in my case) at 0x402C18
            - starting at 0x402900, `OpenServiceA`, `DeleteService`, `DeleteFileA` etc.
            - calls `sub_401210` (=`delete_regKey` in my case) at 0x402AD5, which contains `RegDeleteValueA` etc.
    - The option `-c` sets a configuration key
        - Needs seven arguments to work: Checks `argc` == 7 at 0x402C73. There does not seem to be any checks, to which arguments we pass.
        - call to `sub_402CC5` (=`create_regXPS` in my case) at 0x402CC5
            - `RegCreateKeyExA` (with one parameter being `Subkey` "SOFTWARE\\Microsoft \\XPS"), `RegSetValueExA` (with one parameter being `ValueName` "Configuration")

    - The option `-cc` prints a configuration key
        - **Important:** This option does not work, if the `-c` has never been executed. This option prints the already created configuration key by the `-c` option. If no key was created, nothing is printed to the console.
        - call to `sub_401280`
            - `RegOpenKeyA` (with one parameter being "SOFTWARE\\Microsoft \\XPS"), `RegQueryValueExA` (with one parameter being the name of the registry value "Configuration")
        - As we can see, there is some sort of manipulation with the registry key at "SOFTWARE\\Microsoft \\XPS". The static analysis did not show any more signs of functionality (at least it wasn't clear enough for me). Hence the best thing to do now is to test running the malware with this argument.
    
    - Running the malware with the `-c` option first and the `-cc` option later will result in the following output.
        ```batch
        C:\PATH TO BINARIES\Chapter_9L>Lab09-01_patched.exe -c arg3 arg 4 arg5 arg6 Key
        C:\PATH TO BINARIES\Chapter_9L>Lab09-01_patched.exe -cc arg3 arg 4 arg5 arg6 Key
        k:arg3  h:arg4 p:arg5 per:arg6
        ```
        The `-cc` option prints the 4 extra arguments that were passed to the malware. We can further investigate and look at the registry, where we will find not only the key, but also the fake "Microsoft " folder (with space at the end) and our arguments contained in the Configuration Keys value data.
            <br>
            <img src="image-33.png" width=" 600">
            <br>
        The following flow chart reprents the avaiable options in a condensed and simple manner (author referenced below).
        <br>
        <img src="image-20200502041946535.png" width="500">
        <br>



    // ida check sub_402360 -> sub_402020
    // olly XX
    
    
    
    
    
    // set breakpoint at 402600 to continue from here








1. How can you get this malware to install itself?
    - Patching the binary or passing the argument `-in` (found in the strings) and the correct password `abcd` (or patching the binary).
2. What are the command-line options for this program? What is the password requirement?
    - `-in`, ... // 2do
    - `abcd`
3. How can you use OllyDbg to permanently patch this malware, so that it doesn't require the special command-line password?
4. What are the host-based indicators of this malware?
5. What are the different actions this malware can be instructed to take via the network?
6. Are there any useful network-based signatures for this malware?

**--> snapshot when done**





---
### References
- RegOpenKeyExA function (winreg.h) - https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexa
- Microsoft XPS Document Writer (MXDW) - https://learn.microsoft.com/en-us/windows/win32/printdocs/microsoft-xps-document-writer
- System Error Codes (0-499) - https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-
- Practical Malware Analysis Lab 9-1 - https://bufferoverflowed.wordpress.com/practical-malware-analysis/ollydbg/lab-9/
- Practical Malware Analysis - Chapter 9 Lab Write-up - https://www.jaiminton.com/Tutorials/PracticalMalwareAnalysis/Chapter9/#lab-9-1
- ShellExecuteA function (shellapi.h) - https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea
- Dive into Systems - https://diveintosystems.org/book/C2-C_depth/advanced_cmd_line_args.html
- Online x86 / x64 Assembler and Disassembler - https://defuse.ca/online-x86-assembler.htm#disassembly
- strcmp, wcscmp, _mbscmp, _mbscmp_l - https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcmp-wcscmp-mbscmp?view=msvc-170
- GetModuleFileNameA function (libloaderapi.h) - https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea
- New-Service - https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-service?view=powershell-7.4
- CopyFileA function (winbase.h) - https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfilea
- RegQueryValueExA function (winreg.h) - https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvalueexa