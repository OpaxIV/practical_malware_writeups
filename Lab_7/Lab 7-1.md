# Lab 7
Important: Since my MD-Editor decided to deleted half of my work during a program restart, some of the text has been copied 1:1 from the references below. 

## Lab 7-1
Analyse the malware found in the file Lab07-01.exe.

0. Initial Analysis
- `main` function at 0x401000
  
  - ```
    .text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)
    .text:00401000 _main proc near
    .text:00401000
    .text:00401000 ServiceStartTable= SERVICE_TABLE_ENTRYA ptr -10h
    .text:00401000 var_8= dword ptr -8
    .text:00401000 var_4= dword ptr -4
    .text:00401000 argc= dword ptr  4
    .text:00401000 argv= dword ptr  8
    .text:00401000 envp= dword ptr  0Ch
    .text:00401000
    .text:00401000 sub     esp, 10h
    .text:00401003 lea     eax, [esp+10h+ServiceStartTable]
    .text:00401007 mov     [esp+10h+ServiceStartTable.lpServiceName], offset aMalservice ; "MalService"
    .text:0040100F push    eax             ; lpServiceStartTable
    .text:00401010 mov     [esp+14h+ServiceStartTable.lpServiceProc], offset sub_401040
    .text:00401018 mov     [esp+14h+var_8], 0
    .text:00401020 mov     [esp+14h+var_4], 0
    .text:00401028 call    ds:StartServiceCtrlDispatcherA
    .text:0040102E push    0
    .text:00401030 push    0
    .text:00401032 call    sub_401040
    .text:00401037 add     esp, 18h
    .text:0040103A retn
    .text:0040103A _main endp
    ```
    
    ![](C:\Users\Fabio\AppData\Roaming\marktext\images\2023-12-19-16-41-13-image.png)

- **StartServiceCtrlDispatcherW function:**
  
  - Connects the main thread of a service process to the service control 
    manager, which causes the thread to be the service control dispatcher 
    thread for the calling process.
  
  - **Synthax:**
    
    - ```c
      BOOL StartServiceCtrlDispatcherW(
        [in] const SERVICE_TABLE_ENTRYW *lpServiceStartTable
      );
      ```
  
  - **Parameters:**
    
    - `lpServiceStartTable` - Pointer to an array of [SERVICE_TABLE_ENTRY](https://learn.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-service_table_entrya) structures containing one entry for each service that can execute in the calling process
  
  - **Return Value:**
    
    - !=0 if successful
    
    - =0 if an error occurs, call `GetLastError` for specifics
  
  - Ref.: [StartServiceCtrlDispatcherW function (winsvc.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicectrldispatcherw)

- **SERVICE_TABLE_ENTRYA structure:**
  
  - Specifies the [ServiceMain](https://learn.microsoft.com/en-us/windows/desktop/api/winsvc/nc-winsvc-lpservice_main_functiona) function for a service that can run in the calling process. It is used by the [StartServiceCtrlDispatcher](https://learn.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-startservicectrldispatchera) function.
  
  - **Syntax:**
    
    ```
    typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                    lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
    } SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
    ```
    
    - **Members:**
      - `lpServiceName` - name of a service to be run in this service process
      - `lpServiceProc` - a pointer to a ServiceMain function.
  
  - Ref.: [SERVICE_TABLE_ENTRYA (winsvc.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_table_entrya)
  
  - **LPSERVICE_MAIN_FUNCTIONA callback function:**
    
    - Entry point for a service.
    - Defines a pointer to this callback function.
    - `ServiceMain` is a placeholder for an application-defined function name
    - Ref.: [LPSERVICE_MAIN_FUNCTIONA (winsvc.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nc-winsvc-lpservice_main_functiona)

<br>

- In the context of our `main` function, `MalService` is the `lpServiceName` and the `sub_401040` function the pointer `lpServiceProc` to the process.
  
  - **`sub_401040` at 0x401040:**
    
    <img src="file:///C:/Users/Fabio/AppData/Roaming/marktext/images/2023-12-19-19-31-30-image.png" title="" alt="" width="225">
    
    - Ultilizes functions like `OpenMutexW`, `CreateMutexA`, `OpenSCManagerA`, `GetCurrentProcess`, `GetModuleFileNameA`, `CreateServiceA` and `CreateThread`.
    
    - Conditional case, where `eax == 0` leads to a jump to the right branch at 0x401064. If `eax != 0` the condition is unsatisfied, hence the function returns (0) and calls `ExitProcess`.
    
    - **Entry Block:**
      
      <img title="" src="file:///C:/Users/Fabio/AppData/Roaming/marktext/images/2023-12-19-19-20-04-image.png" alt="" width="480">
      
      - `OpenMutexA` - Opens an existing named mutex object.
        
        - **Synthax:**
          
          ```c
          HANDLE OpenMutexW(
            [in] DWORD   dwDesiredAccess,
            [in] BOOL    bInheritHandle,
            [in] LPCWSTR lpName
          );
          ```
        
        - **Parameters:**
          
          - `[in] dwDesiredAccess` - The access to the mutex object. Only the **SYNCHRONIZE** access right is required to use a mutex; to change the mutex's security, specify **MUTEX_ALL_ACCESS**.
             The function fails if the security descriptor of the specified object 
            does not permit the requested access for the calling process.
            
            - List of Access Rights: [Synchronization Object Security and Access Rights - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights))
            
            - In the case of this malware, `1F0001h` is pushed onto the stack.
            
            - According to the Microsoft Reference, this value corresponds to `MUTEX_ALL_ACCESS`. - **All possible access rights for a mutex object.** Use this right only if your application requires access beyond that granted by the standard access rights. Using this access right increases the possibility that your application must be run by an **Administrator**.
              
              - Ref.: [Synchronization Object Security and Access Rights - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights)
          
          - `[in] bInheritHandle` - If this value is **TRUE**, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle. In the case of our malware, this is set to 0.
          
          - `[in] lpName` - The name of the mutex to be opened. In our case "HGL345".
        
        - **Return Value:**
          
          - If the function succeeds, the return value is a handle to the mutex object.
          
          - If the function fails, the return value is **NULL**. To get extended error information, call [GetLastError](https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).
        
        - Ref.:[OpenMutexW function (synchapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openmutexw)
    
    - **True Condition (`eax == 0`)**:
      
      - `CreateMutexA` - Creates or opens a named or unnamed mutex object.
        
        - **Synthax:**
          
          - ```c
            HANDLE CreateMutexA(
              [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,
              [in]           BOOL                  bInitialOwner,
              [in, optional] LPCSTR                lpName
            );
            ```
        
        - **Parameters:**
          
          - `[in, optional] lpMutexAttributes` - A pointer to a [SECURITY_ATTRIBUTES](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) structure. If this parameter is **NULL**, the handle cannot be inherited by child processes. In the case of this malware it is 0.
          
          - `[in] bInitialOwner` - If this value is **TRUE** and the caller created the mutex, the calling thread obtains initial ownership of the mutex object.
        
        - **Return Value:**
          
          - If the function succeeds, the return value is a handle to the newly created mutex object.
          
          - If the function fails, the return value is **NULL**. To get extended error information, call GetLastError.
        
        - Ref.: [CreateMutexA function (synchapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa)
      
      - `OpenSCManagerA function` - Establishes a connection to the service control manager on the specified
         computer and opens the specified service control manager database.
        
        - **Synthax:**
          
          - ```c
            SC_HANDLE OpenSCManagerA(
              [in, optional] LPCSTR lpMachineName,
              [in, optional] LPCSTR lpDatabaseName,
              [in]           DWORD  dwDesiredAccess
            );
            ```
          
          - 
        
        - Ref.: [OpenSCManagerA function (winsvc.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-openscmanagera)
      
      - `GetCurrentProcess` - Retrieves a pseudo handle for the current process.
        
        - **Snythax:**
          
          - ```c
            HANDLE GetCurrentProcess();
            ```
        
        - **Return Value:**
          
          - The return value is a pseudo handle to the current process.
        
        - Ref.: [GetCurrentProcess function (processthreadsapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess)
      
      - `GetModuleFileNameA` - Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current 
        process.
        
        - **Synthax:**
          
          - ```c
            DWORD GetModuleFileNameA(
              [in, optional] HMODULE hModule,
              [out]          LPSTR   lpFilename,
              [in]           DWORD   nSize
            );
            ```
        
        - **Parameters:**
          
          - `[in, optional] hModule` - A handle to the loaded module whose path is being requested.
          
          - `[out] lpFilename` - A pointer to a buffer that receives the fully qualified path of the module.
          
          - `[in] nSize` - The size of the *lpFilename* buffer, in **TCHARs** (A Win32 character string that can be used to describe ANSI, DBCS, or Unicode strings.).
        
        - **Return Value:**
          
          - If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character.
          
          - If the buffer is too small to hold the module name, the string is truncated to *nSize* characters including the terminating null character, the function returns *nSize*, and the function sets the last error to **ERROR_INSUFFICIENT_BUFFER**.
          
          - **Windows XP:**  If the buffer is too small to hold the module name, the function returns *nSize*. The last error code remains **ERROR_SUCCESS**. If *nSize* is zero, the return value is zero and the last error code is **ERROR_SUCCESS**.
          
          - If the function fails, the return value is 0 (zero). To get extended error information, call [GetLastError](https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).
        
        - Ref.:[GetModuleFileNameA function (libloaderapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea)
      
      - `CreateServiceA` - Creates a service object and adds it to the specified service control manager database.
        
        - **Synthax:**
          
          - ```c
            SC_HANDLE CreateServiceA(
              [in]            SC_HANDLE hSCManager,
              [in]            LPCSTR    lpServiceName,
              [in, optional]  LPCSTR    lpDisplayName,
              [in]            DWORD     dwDesiredAccess,
              [in]            DWORD     dwServiceType,
              [in]            DWORD     dwStartType,
              [in]            DWORD     dwErrorControl,
              [in, optional]  LPCSTR    lpBinaryPathName,
              [in, optional]  LPCSTR    lpLoadOrderGroup,
              [out, optional] LPDWORD   lpdwTagId,
              [in, optional]  LPCSTR    lpDependencies,
              [in, optional]  LPCSTR    lpServiceStartName,
              [in, optional]  LPCSTR    lpPassword
            );
            ```
        
        - **Parameters:**
          
          - `[in] hSCManager` - A handle to the service control manager database.
          
          - `[in] lpServiceName` - The name of the service to install.
          
          - `[in, optional] lpDisplayName` - The display name to be used by user interface programs to identify the service.
          
          - `[in] dwDesiredAccess` - The access to the service.
          
          - `[in] dwServiceType` - The service type.
          
          - `[in] dwStartType` - The service start options.
          
          - `[in] dwErrorControl` - The severity of the error, and action taken, if this service fails to start.
          
          - `[in, optional] lpBinaryPathName` - The fully qualified path to the service binary file.
          
          - `[in, optional] lpLoadOrderGroup` - The names of the load ordering group of which this service is a member.  Specify NULL or an empty string if the service does not belong to a group.
          
          - `[out, optional] lpdwTagId` - A pointer to a variable that receives a tag value that is unique in the group specified in the *lpLoadOrderGroup* parameter.
          
          - `[in, optional] lpDependencies` - A pointer to a double null-terminated array of null-separated names of services or load ordering groups that the system must start before this service.
          
          - `[in, optional] lpServiceStartName` - The name of the account under which the service should run.
          
          - `[in, optional] lpPassword` - The password to the account name specified by the *lpServiceStartName* parameter.
        
        - Ref.:[CreateServiceA function (winsvc.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicea)
        
        - `SystemTimeToFileTime` - Converts a system time to file time format. System time is based on Coordinated Universal Time (UTC).
          
          - **Synthax:**
            
            - ```C
              BOOL SystemTimeToFileTime(
                [in]  const SYSTEMTIME *lpSystemTime,
                [out] LPFILETIME       lpFileTime
              );
              ```
          
          - **Parameters:**
            
            - `[in] lpSystemTime` - A pointer to a [SYSTEMTIME](https://learn.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-systemtime) structure that contains the system time to be converted from UTC to file time format.
            - `[out] lpFileTime` - A pointer to a [FILETIME](https://learn.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-filetime) structure to receive the converted system time.
          
          - **Return Value:**
            
            - If the function succeeds, the return value is nonzero.
            - If the function fails, the return value is zero. To get extended error information, call [GetLastError](https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).
          
          - Ref.: [SystemTimeToFileTime function (timezoneapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-systemtimetofiletime)
        
        - `CreateWaitableTimerA` - Creates or opens a waitable timer object.
          
          - **Waitable Timer Objects:** - A *waitable timer object* is a synchronization object whose state
             is set to signaled when the specified due time arrives. There are two types of waitable timers that can be created: manual-reset and synchronization. A timer of either type can also be a periodic timer.
            - **manual-reset timer** - A timer whose state remains signaled until [**SetWaitableTimer**](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) is called to establish a new due time.
            - **synchronization timer** - A timer whose state remains signaled until a thread completes a wait operation on the timer object.
            - **periodic timer** - A timer that is reactivated each time the specified period expires, until the timer is reset or canceled. A periodic timer is either a periodic manual-reset timer or a periodic synchronization timer.
            - Ref.: [Waitable Timer Objects - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/sync/waitable-timer-objects)
          - **Synthax:**
            - ```c
              HANDLE CreateWaitableTimerW(
                [in, optional] LPSECURITY_ATTRIBUTES lpTimerAttributes,
                [in]           BOOL                  bManualReset,
                [in, optional] LPCWSTR               lpTimerName
              );
              ```
          - **Parameters:**
            - `[in, optional] lpTimerAttributes` - A pointer to a [SECURITY_ATTRIBUTES](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) structure that specifies a security descriptor for the new timer object
               and determines whether child processes can inherit the returned handle.
            - `[in] bManualReset` - If this parameter is **TRUE**, the timer is a manual-reset notification timer. Otherwise, the timer is a synchronization timer.
            - `[in, optional] lpTimerName` - The name of the timer object. The name is limited to **MAX_PATH** characters.
          - Ref.: [CreateWaitableTimerW function (synchapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw)
        
        - `SetWaitableTimer`
        
        - `WaitForSingleObject`
        
        - `CreateThread`
        
        - `CreateThread`
        
        - `Sleep`
    
    - **False Condition (`eax !=0`):**
      
      - `ExitProcess` - Ends the calling process and all its threads.
      
      - Ref.: [ExitProcess function (processthreadsapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess)
  
  - **Timeline:**
    
    - //2add: chronologically list all function calls
    
    <br>
1. How does this program ensure that it continues running (achieves persistence) when the computer is restarted?
   
   - Using the `CreateServiceA` function and the parameter `dwStartType` set to 2
   
   - `SERVICE_AUTO_START` (0x00000002) - A service started automatically by the service control manager during system startup. For more information, see [Automatically Starting Services](https://learn.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services).
   
   - `.text:004010AB push    2               ; dwStartType`
   
   - Establishes connection to the service control manager (OpenSCManagerA) — requires administrator permissions
   
   - gets handle of current process (GetCurrentProcess), gets File name (GetModuleFileNameA)
   
   - Creates the service named “**Malservice**” wich auto starts each time. (CreateServiceA)

2. Why does this program use a mutex?
   
   - Program uses mutex to not reinfect the same machine again.
   
   - Opens mutex (OpenMutexA) with the name “**HGL345**” with **MUTEX_ALL_ACCESS.**
   
   - If instance is already created, terminates program, otherwise creates one.

3. What is a good host-based signature to use for detecting this program?
   
   - "Malservice" is the name of the service.
   
   - "HGL345" mutex

4. What is a good network-based signature for detecting this malware?
   
   <img src="file:///C:/Users/Fabio/AppData/Roaming/marktext/images/2023-12-21-20-19-49-image.png" title="" alt="" width="452">   
   <img title="" src="file:///C:/Users/Fabio/AppData/Roaming/marktext/images/2023-12-21-20-20-16-image.png" alt="" width="351"> 
   
   - User Agent “Internet Explorer 8.0”
   
   - Connects to server “[http://www.malwareanalysisbook.com](http://www.malwareanalysisbook.com)" for infinity time

5. What is the purpose of this program?
   
   - Designed to create the service for persistence
   
   - Waits for long time till 2100 years
   
   - Creates thread, which connects to “[http://www.malwareanalysisbook.com](http://www.malwareanalysisbook.com)" forever, this loop never ends.
   
   - The rest code is not accessed: 20 times calls thread, which connects to web page and sleeps for 7.1 week long before program exits.
   
   - Infinitive loop is created to **DDOS attack** the page. Attacker is only able to compromised the web page if has more resources than hosting provider can handle.

6. When will this program finish executing?
   
   - Program will wait 2100 Years to finish. This time represents midnight on January 1, 2100.
   
   - ![](C:\Users\Fabio\AppData\Roaming\marktext\images\2023-12-21-20-26-20-image.png)
   
   - Creates new thread (CreateThread), important argument is lpStartAddress, which indicates the start of the thread and connects to internet for 20 times.
   
   - Then sleeps for ~ 7.1 weeks and exits.
   
   - ![](C:\Users\Fabio\AppData\Roaming\marktext\images\2023-12-21-20-27-58-image.png)


References:

- Malware analysis Lab 7 - https://medium.com/@hakingas/malware-analysis-lab-7-6dcb1c1693f7
- Practical Malware Analysis - Solutions of the Book
