# Lab 7
Important: Since my MD-Editor decided to deleted half of my work during a program restart, some of the text has been copied 1:1 from the references below. 

## Lab 7-3

For this lab, we obtained the malicious executable, Lab07-03.exe, and DLL, LAb07-03.dll, prior to executing. This is important to note because the malware of might change once it runs. Both files were found in the same directory on the victim machine. If you run the program, you should ensure that both files are in the same directory on the analysis machine. A visible IP string beginning with 127 (a loopback address) connects to the local machine. (In the real version of this malware, this address connects to a remote machine, but we've set it to connect to localhost to protect you.)

**Warning: This lab may cause considerable damage to your computer and may be difficult  to remove once installed. Do not run this file without a virtual machine with snapshot taken prior to execution.**

### Static Analysis
#### **Lab07-03.dll**
  - **Strings:**
    - "hello"
    - "127.26.152.13" - IP-Adress possibly from the Remote Command Server 
    - "sleep" - written in lowercase instead of the also present `Sleep` function
  - **Insteresting Imports:**
    - From WS2_32 library (ws2_32.dll): `inet_adr`, `connect`, `send` ... Generally speaking, this library contains network functionalities.
      - Ref.: https://learn.microsoft.com/en-us/windows/win32/winsock/initialization-2 

  - **Interesting Exports:**
    - None, which is odd due to the nature of a .dll file.
  - **Disassembly:**
    - `DLLEntryPoint` at 0x100012FA
      - Does not contain much information for our purposes
      - call to `DllMain`
    - `DLLMain` at 0x10001010
      - Contains many lines of code.
      - Focus on the `call` instructions: `OpenMutexA`, `WSAStartup`, `WSACleanup`, `CreateProcessA` ...
      - The following picture contains all the `call` instructions of the `DLLMain` function in hierarchical order. Important to note is the fact, that not all of these functions may always be executed due to branching decisions.
        ![Alt text](image-2.png)
        - `OpenMutex` -  Either opens an existing Mutex Object or returns an error. Used again by this malware to make sure that only one instance of itself is running simultaneously.
        - `WSAStartup function` - initiates use of the Winsock DLL by a process, returns 0 if successfull, else a given error code.
        Ref.: https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup

      - **Calling Order:**
        - The first API function being called is `OpenMutexA`.
        - If `OpenMutexA`returns FALSE, `CreateMutexA` and `WSAStartup`get called next. Else the program terminates.
        - If `WSAStartup` returns 0, the program continues to 0x1000108C, else returns an error code and terminates the program.
        - Parameters `protocol` (6 = IPPROTO_TCP), `type` (1 = SOCK_STREAM) and `af` (2 = AF_INET) are pushed onto the stack and the  `socket` function is called. Return value is the descriptor referencing the new socket, else a given error code.
        Ref.: https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket
        - If no error is returned, a jump to 0x100010A3 occurs, in which `inet_addr`, `htons` and `connect` are called.
          - `inet_addr` - converts a string containing an IPv4 dotted-decimal address into a proper address for the IN_ADDR structure.
          - `htons` - converts a u_short from host to TCP/IP network byte order (which is big-endian). Before calling this function the number 0x50 is pushed onto the stack, which converted into decimal is 80. This is the number of the port
          - `connect` - establishes a connection to a specified socket.
        - After some checks and conditional jumps, we (may) reach the call to `CreateProcess`.
          - `CreateProcessA` - Creates a new process and its primary thread. The new process runs in the security context of the calling process. https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
        - After that the `send` function, onto which the parameter `char *buf` with the value "hello" (among others) is passed.
          - `send` - sends data on a connected socket. https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send
        - In the following basic block the function `shutdown` is called.
          - `shutdown` - disables sends or receives on a socket. https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown
        - `recv` is called afterwards.
          - `recv` - receives data from a connected socket or a bound connectionless socket.
          - if 0 (or less) is returned via %eax, then a short jump returning to a previous point in the function. Else we proceed to 0x1000113C.
        - At this point the variable `buf` is compared to the string "sleep". If 0 is returned by `strncmp` the program proceeds, else the function `Sleep` is called (which puts the program to sleep for 0x60000 = 393216 dec, hence ~ 393 seconds), the control flow passed  to 0x100010E9 again (re-initiating the `send` function) and repeating the whole process.
        - Some instructions later the same string comparasion occurs with `buf` and "exec". If `strncmp` returns 0, we continue the programs execution and call the function `CreateProcessA`, which creates a process out of the parameters seen in the disassembly.
          ```
          .text:10001179 mov     ecx, 11h
          .text:1000117E lea     edi, [esp+1208h+StartupInfo]
          .text:10001182 rep stosd
          .text:10001184 lea     eax, [esp+1208h+ProcessInformation]
          .text:10001188 lea     ecx, [esp+1208h+StartupInfo]
          .text:1000118C push    eax             ; lpProcessInformation
          .text:1000118D push    ecx             ; lpStartupInfo
          .text:1000118E push    0               ; lpCurrentDirectory
          .text:10001190 push    0               ; lpEnvironment
          .text:10001192 push    8000000h        ; dwCreationFlags
          .text:10001197 push    1               ; bInheritHandles
          .text:10001199 push    0               ; lpThreadAttributes
          .text:1000119B lea     edx, [esp+1224h+CommandLine]
          .text:100011A2 push    0               ; lpProcessAttributes
          .text:100011A4 push    edx             ; lpCommandLine
          .text:100011A5 push    0               ; lpApplicationName
          .text:100011A7 mov     [esp+1230h+StartupInfo.cb], 44h ; 'D'
          .text:100011AF call    ebx ; CreateProcessA
          ```
        - Most interestingly is the `CommandLine` argument, which defines the command line to be executed. https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
          - It is never explicitly set when looking in the disassembly (set at runtime).
        - At the beginning of the `MainDLL` function we see `buf= byte ptr -1000h` and `CommandLine= byte ptr -0FFBh`. We get a difference of 5 bytes between `buf` and `CommandLine` (0x1000 - 0x0FFB = 5). - *Info: In IDA variables have negative, while arguments positive values.*
        - If we consider, that `buf` must contain "exec" to let the program finish "the correct way", we get a discrepancy of one byte. This one byte represents the space between the "exec" command and the `CommandLine` argument.
        ![Alt text](<1 A9a8g2zE8tZkQoAjFIO2nQ.webp>)


//read the full medium article and understand it


#### Lab07-03.exe
**Interesting Strings:**
- "C:\\Windows\\System32\\Kernel32.dll" - original kernel32.dll file
- "C:\\windows\\system32\\kerne132.dll" - renamed kernel132.dll file, perhaps used for confusion / undetection
- "Lab07-03.dll" - importing the separate .dll file.
- "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE" - addition from the authors of the practical malware analysis book, will probably be displayed before executing the program

**Interesting Imports:**
<br>
<img src="image-3.png" width="400">
<br>
- **File Modification**
  - The following functions imply that this malware probably opens a file and maps it into memory.  
  - `CreateFile` (0x401495-0x4014AC)- Creates or opens (!) a file or I/O device.
    - **Parameters:**
      - `lpFileName` - The name of the file or device to be created or opened. In the case of the malware *"C:\\Windows\\System32\\Kernel32.dll"*.
    - Ref.: https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
  - `CreateFileMapping` - Creates or opens a named or unnamed file mapping object for a specified file.
    -Ref.: https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga
  - `MapViewOfFile` - https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile
    - Ref.: https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile

- **Indexing**
  - The following functions imply, that the malware searches directories and uses copies files that it finds.
    - `FindFirstFileA` - Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).
      - Ref.:https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea
    - `FindNextFileA` - Continues a file search from a previous call to the FindFirstFile, FindFirstFileEx, or FindFirstFileTransacted functions.
      - Ref.: https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findnextfilea
    - `CopyFileA` - Copies an existing file to a new file.
      - Ref.: https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfilea
    - Interesting to point out is also the fact, that the Lab07-03.dll file is never important and also any functions like `LoadLibrary` and `GetProcAddress`. Processes call LoadLibrary or LoadLibraryEx to explicitly link to a DLL.
      - Ref.:
        - https://learn.microsoft.com/en-us/cpp/build/loadlibrary-and-afxloadlibrary?view=msvc-170
        - https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya

    - **Interesting Variables:**
      - db `ExistingFileName`= "Lab07-03.dll", being the second file in the directory of the malware


- **Disassembly:**
  - **Main Function**
    - `main` function at 0x401440
    - The first basic block contains a check for `argc`, which is the parameter given to the `main` function. `argc` holds the count of arguments given to the function and if the count is below 2, we direcly jump to the end of the program.
      ```
      .text:00401440 mov     eax, [esp+argc]
      .text:00401444 sub     esp, 44h
      .text:00401447 cmp     eax, 2
      .text:0040144A push    ebx
      .text:0040144B push    ebp
      .text:0040144C push    esi
      .text:0040144D push    edi
      .text:0040144E jnz     loc_401813
      ```
    - At 0x401454 the `argv` array is loaded into %eax via the `mov     eax, [esp+54h+argv]` instruction call. "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE" will be loaded into %esi. In short succession the first parameter from `argv` is loaded into %eax via access into memory `mov     eax, [eax+4]`.
    - The next basic block presents a comparison between these registers %esi and %eax. If these values are the same, the program continues, else 
      ```
      .text:00401460 mov     dl, [eax]
      .text:00401462 mov     bl, [esi]
      .text:00401464 mov     cl, dl
      .text:00401466 cmp     dl, bl
      .text:00401468 jnz     short loc_401488
      ```
    - At 0x4014A7 `CreateFileA` is called with the interesting `FileName` parameter "C:\\Windows\\System32\\Kernel32.dll". This function creates or opens (!) an extisting file or I/O device. In our case it seems like the well Windows Kernel32.dll file is being opened.
    - At 0x1014F0 the function `CreateFileA` is again called but this time with the `ExistingFileName` parameter which contains "Lab07-03.dll".
    - Further into the disassembly the functions `CreateFileMappingA` and `MapViewOfFile` are called (both used for mapping files into memory). In between these functions and the "last section" of this program is a lot of code and even two sub-routines. It has been taken a look at them and the code but not in great detail, since most of it is memory manipulation and other (to me) unknown stuff (even the book only glances over it and states, that it is not worth looking into it).
    - Looking at 0x4017D4 we see the `CloseHandle` function, which is used to close the file handles in our case. With this information we know, that the program has finished editing those files.
    - In another step `CopyFileA` is called, to which the two parameters `NewFileName` (= "C:\\windows\\system32\\kerne132.dll") and `ExistingFileName` (= "Lab07-03.dll") are passed. In other words the file Lab07-03.dll gets saved into "C:\\windows\\system32\\kerne132.dll", which also implies a name change to "kernel132.dll". The idea is to immitate the actual "kernel32.dll" file, also present in the system32 folder.
    - We finaly reach the last basic block of the `main` method at 0x401806. In it the variable `aC` is pushed onto the stack, which contains the value "C:\\\\" (corresponding with the start of an absolute path to the C: drive in Windows). After the push the sub-routine sub_4011E0 is called.
  - **Sub-Routine sub_4011E0**
    - starts at 0x4011E0
    - contains some interesting library imports
    - Function Signature: `int __cdecl sub_4011E0(LPCSTR lpFileName, int)` - the parameters name `lpFileName` was set by IDA, corresponding to the pushed variable `aC` containing "C:\\\\"
    - The function `FindFirstFileA` is called at 0x401204 taking also the parameter `lpFileName` (= "C:\\\\) and `FindFileData` (= a pointer to the *WIN32_FIND_DATA* structure that receives information about a found file or directory).
      ```C
      typedef struct _WIN32_FIND_DATAA {
        DWORD    dwFileAttributes;
        FILETIME ftCreationTime;
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        DWORD    nFileSizeHigh;
        DWORD    nFileSizeLow;
        DWORD    dwReserved0;
        DWORD    dwReserved1;
        CHAR     cFileName[MAX_PATH];
        CHAR     cAlternateFileName[14];
        DWORD    dwFileType; // Obsolete. Do not use.
        DWORD    dwCreatorType; // Obsolete. Do not use
        WORD     wFinderFlags; // Obsolete. Do not use
      } WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
      ```
    - The function `FindFirstFileA` searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used). In other words the program starts a search trough the "C:\\\\" drive.
    - Seen in the code are also ``
    - Continuing our analysis presents us again with a lot of code and function specific functionalities. Recommended again by the book is to just glance over it, since it does not contain anything more interesting in regards to our malware.
    - (This is not further elaborated upon, but interesting to note is the fact, that the program also checks for the current directory "." and the root directory ".." at 0x401224 and 0x401262 respectively.) 
    - Jumping directly to the address 0x4013A1 we can see a variable `aExe` with the value ".exe" being pushed onto the stack. Since this is the most recent push instruction before the call of `stricmp` at 0x4013F6, we can be sure that there is some sort of comparasion between file names. The program specifically searches for ".exe" files in the C:\\\\ directory and does some (to us yet unknown) operations these files.
    <br>
    <img src="image-4.png" width="300">
    <img src="image-5.png" width="250">
    <br>
    - At some point we can even see a recursive call to itself ` call    sub_4011E0` at 0x40134F.
    - To further understand the programs functionality, we need to examine the function found at 0x4010A0 right after the `stricmp` call.

  - **Sub-Routine sub_4010A0**
    - Takes the variable `lpFileName` (= C:\\\\) as a parameter.
    - Again focusing only on the function calls, since it would else take too long to check every line of code.
    - At the beginning three WinAPI functions, namely `CreateFileA` (opens or creates a file), `CreateFileMappingA` (returns a handle to the file mapping object, the handle will be used when creating a file view so that you can access the shared memory) and `MapViewOfFile` (maps a view of a file mapping into the address space of a calling process), are called. So basically functions, which somehow map files into memory.
    - Furthermore `IsBadReadPtr` checks the calling process has read access to the specified range of memory. It returns 0 if the calling process has access rights and returns a non-zero value in the opposite case. https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-isbadreadptr
    - At 0x40116E we see a comparasion with `stricmp` between "kernel32.dll" and "String1". The actual value of "String1" is unknown to us, though this string has also been used at 0x401173 and compared with ".exe".
    <br>
    <img src="image-6.png" width="400">
    <br>
    - To find out what value it holds, we at first look at the next basic block. In there we see the `repne scasb` (REPeat while Not Equal and SCan A String) and `rep movsd` (REPeat and MOVe String Double word) instructions. According to the book, `repne scasb` is basically a `strlen` function. On the other hand `rep movsd` is equal to the `memcopy` function.
    - We can say, that if the string "kernel32.dll" is found (`stricmp == 0`) Backtracing the relevant registers %edi and %edx shows us, that the string "kernel32.dll" is replaced, if itself is found. Some instructions above at 0x40118C we see a double word being moved into %esi.
      ```
      .text:0040118C mov     esi, offset dword_403010
      .text:00401191 mov     edi, ebx
      .text:00401193 shr     ecx, 2
      .text:00401196 rep movsd
      ```
    - When clicking ot the dword_403010 value, we see the following hexadecimal values:
      ```
      .data:00403014 dword_403014    dd 32333165h            ; DATA XREF: _main+1B9↑r
      .data:00403018 dword_403018    dd 6C6C642Eh            ; DATA XREF: _main+1C2↑r
      .data:0040301C dword_40301C    dd 0                    ; DATA XREF: _main+1CB↑r
      ```
    - Hex values beginning with 3, 4, 5, 6 or 7 are ASCII characters. Hitting "A" on the keyboard will convert them accordingly. Which results in:
      ```
      .data:00403010 aKerne132Dll    db 'kerne132.dll',0     ; DATA XREF: sub_4010A0+EC↑o
      .data:00403010                                         ; _main+1A8↑r ...
      .data:0040301D                 db    0
      .data:0040301E                 db    0
      .data:0040301F                 db    0
      ```
    - We can now say, that the malware searches trough the file system for every file ending in ".exe", finds a location in that file with the string "kernel32.dll" and replaces it with "kernel132.dll". From the previous analysis about the .dll file we conclude, that Lab07-03.dll is copied into "C:\\Windows\System32" and named "kernel132.dll".
    - Summarized we can say, that the malware modifies executables so that they access "kerne132.dll" instead of "kernel32.dll". This indicates that "kerne132.dll" is loaded by executables that are modified to load "kerne132.dll" instead of "kernel32.dll".  

### Dynamic Analysis
- Running in the WinXP VM.
- To run the malware, input `Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE`
- Make sure that the .exe file is in the same folder as the .dll file.

- **Process Monitor:**
  - Filter set to *"Process Name - is - Lab07-03.exe - then - include"*
  - After running the .exe we can see a huge amount of process traces in ProCMon.s
    <br>
    <img src="image-7.png" width="700">
    <br>
  - Literally the whole system gets searched and all .exe files on the system get modified.
  -  As an exampled let's look at the pepinstp.exe file:
    <br>
    <img src="image-8.png" width="800">
    <img src="image-9.png" width="400">
    <br>
  - Using dependecy walker we see, that the kernel32.dll library has been replaced with *kerne132.dll* library.

1. How does this program achieve persistence to ensure that it continues running when the computer is restarted?
  - Writes a DLL to C:\\Windows\System32 and modifying every .exe file on the system to import that DLL.
2. What are two good host-based signatures for this malware?
  - hard-coded file name "kerne132.dll"
  - hard-coded mutex name "SADFHUHF"
3. What is the purpose of this program.
  - Create difficult-to-remove backdoor that connects to a remote host. The backdoor has two commands: one to execute a command and one to sleep.
4. How could you remove this malware once it is installed?
  - Use backups, since replacing the "kerne132.dll" dependency from every modified .exe file on the system is too tideous.

---

References:

- Malware analysis Lab 7 - https://medium.com/@hakingas/malware-analysis-lab-7-6dcb1c1693f7
- Practical Malware Analysis - Solutions of the Book
- Creating a File Mapping Object - https://learn.microsoft.com/en-us/windows/win32/memory/creating-a-file-mapping-object
